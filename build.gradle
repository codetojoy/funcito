apply plugin: 'java'
apply plugin: 'maven'
apply plugin: 'signing'
apply plugin: 'idea'

group = 'com.googlecode.funcito'

task wrapper(type: Wrapper) {
    gradleVersion = '1.1'
}

idea.project.ipr {
    withXml { provider ->
        provider.node.component.find { it.@name == 'VcsDirectoryMappings' }.mapping.@vcs = 'Git'
    }
}

repositories {
    mavenCentral()
//    mavenRepo urls: "https://oss.sonatype.org/content/groups/public/"
    maven {
            url 'http://repo.typesafe.com/typesafe/repo'
    }
}

configurations {
    jarjar
}

dependencies {
    // functional APIs
    compile group: 'com.google.guava', name: 'guava', version: 'r08'
    compile group: 'org.functionaljava', name: 'functionaljava', version: '3.0', transitive: false
    compile group: 'org.codehaus.jedi', name: 'jedi-core', version: '3.0.5', transitive: false
    compile group: 'play', name: 'play_2.9.1', version: '2.0', transitive: false
    compile group: 'org.easytesting', name: 'fest-assert-core', version: '2.0M7', transitive: false
    compile group: 'org.hamcrest', name: 'hamcrest-core', version: '1.2', transitive: false
    compile group: 'net.sourceforge.collections', name: 'collections-generic', version: '4.01', transitive: false

    // internals
    compile group: 'cglib', name: 'cglib-nodep', version: '2.2'
    compile group: 'org.objenesis', name: 'objenesis', version: '1.2'
    compile group: 'org.javassist', name: 'javassist', version: '3.14.0-GA'

    // test
    testCompile group: 'junit', name: 'junit', version: '4.10'
    testCompile group: 'org.mockito', name: 'mockito-core', version: '1.8.5'
    // will eventually need caliper 1.0 or greater when it is released
    testCompile group: 'com.google.caliper', name: 'caliper', version: '0.5-rc1'

    testRuntime group: 'net.sourceforge.cobertura', name: 'cobertura', version: '1.9.4.1'
    
    // packaging    
    jarjar group: 'com.googlecode.jarjar', name: 'jarjar', version: '1.3'
}

// sourceSets
sourceSets.main.java.srcDirs 'src', 'examples'
sourceSets.main.resources.srcDir 'resources'
sourceSets.test.java.srcDirs 'test'

///////////////////////////
// Local vars

final String PROP_FILE = "Funcito.properties"
final String BUILD_INFO_FILE = "buildInfo.txt"
final String BUILD_NUMBER = "BUILD_NUMBER"

def vars = new Expando()

// env
vars.envMap = System.getenv()

// version
def propFile = new File("resources/${PROP_FILE}")
assert propFile.exists()
def properties = new Properties()
properties.load(new FileReader(propFile))
version = properties.getProperty('funcito.version')

println "***** Funcito v ${version}"

// CI server versus local

vars.srcJarFilename = "${project.name}-${version}-sources.jar"
vars.docJarFilename = "${project.name}-${version}-javadoc.jar"
vars.jarFilename = "/${project.name}-${version}.jar"

vars.isJenkins = vars.envMap.keySet().contains(BUILD_NUMBER)
 
if (vars.isJenkins) {
    def formatter = new java.text.SimpleDateFormat("dd-MMM-yyyy")
    def now = formatter.format(new Date())
    def buildNumber = vars.envMap.get(BUILD_NUMBER)
    vars.srcJarFilename = "${project.name}-${version}-sources-SNAPSHOT-${buildNumber}_${now}.jar"
    vars.docJarFilename = "${project.name}-${version}-javadoc-SNAPSHOT-${buildNumber}_${now}.jar"
    vars.jarFilename = "/${project.name}-${version}-SNAPSHOT-${buildNumber}_${now}.jar"
}

///////////////////////////
// Tasks

// create build info file
task buildInfo() {
   def buildInfoFile = "resources/${BUILD_INFO_FILE}"
   ant.delete(file: buildInfoFile)
   def jenkinsVars = ["BUILD_NUMBER", "BUILD_ID", "JOB_NAME", "BUILD_TAG",
               "EXECUTOR_NUMBER", "NODE_NAME", "NODE_LABELS", 
               "JAVA_HOME", "WORKSPACE", "HUDSON_URL", "JOB_URL",
               "SVN_REVISION", "CVS_BRANCH"]

   new File(buildInfoFile).withWriter { writer ->
       vars.envMap.each { key, value ->
           if (jenkinsVars.contains(key)) { 
               writer.write("${key} = ${value}\n") 
           }
       }
   }
}

javadoc {
    exclude 'org/funcito/example/**'
    options.use = true
    options.links = [
        'http://docs.oracle.com/javase/1.5.0/docs/api/',
        'http://docs.guava-libraries.googlecode.com/git-history/v11.0.1/javadoc/',
        'http://functionaljava.googlecode.com/svn/artifacts/3.0/javadoc/',
        'http://jedi.codehaus.org/javadoc/',
        'http://www.jarvana.com/jarvana/view/net/sourceforge/collections/collections-generic/4.01/collections-generic-4.01-javadoc.jar!/',
        'http://www.playframework.org/documentation/api/2.0/java/',
    ]
}

// build src jar
task sourcesJar(type: Jar, dependsOn: [buildInfo,test]) {
    classifier = 'sources'
    archiveName = vars.srcJarFilename

    from(sourceSets.main.java.srcDirs)
    from(sourceSets.main.resources.srcDirs)
    from('docs')
}

task javadocJar(type: Jar, dependsOn: [buildInfo,test,javadoc]) {
    classifier = 'javadoc'
    archiveName = vars.docJarFilename

    from('docs') {
        include 'ReadMe.txt'
        include 'License.txt'
    }

    into('docs') {
        from('build/docs')
    }
}

jar {
    def targetDir = "build/libs"
    def targetJar = targetDir + vars.jarFilename
    def classesDir = "build/classes/main"
    
    doLast {
        project.ant {
            // define jarjar
            taskdef name: "jarjar", classname: "com.tonicsystems.jarjar.JarJarTask", classpath: configurations.jarjar.asPath
            jarjar(jarfile: targetJar) {

                fileset(dir: classesDir) {
                    exclude(name: 'org/funcito/example/**/*')
                    exclude(name: 'org/funcito/example')
                }

                fileset(dir: 'resources') {
                    include(name: PROP_FILE)
                    include(name: BUILD_INFO_FILE)
                }

                fileset(dir: 'docs') {
                    include(name: 'ReadMe.txt')
                    include(name: 'License.txt')
                }

                configurations.compile.findAll {
                    if (it.name =~ /objenesis/) {
                        zipfileset(src: "${it.path}")
                    }
                }
                rule(pattern: 'org.objenesis.**', result: 'org.funcito.thirdparty.objenesis.@1')
            }
            // JarJar has a bug as of 1.1 that leaves the original directories (now empty) in the jarfile
            // There was a changelist released in 1.3 that was supposed to fix this, but it doesn't seem
            // to work.  If it gets fixed in later releases, we can remove the below lines
            mkdir(dir: "build/exploded")
            unzip(src: targetJar, dest: "build/exploded")
            copy (includeemptydirs: false, todir: "build/unpolluted") {
                fileset(dir: "build/exploded")
            }
            jar(destfile: targetJar) {
                fileset(dir: "build/unpolluted")
            }
        }
    }
}

artifacts {
    archives jar
    archives sourcesJar
    archives javadocJar
}

// build all jars
def allJars = tasks.withType( Jar )
task jarAll(overwrite: true, dependsOn: allJars )

task runBenchmark(type: JavaExec, dependsOn: test) {
    def vmVer = System.getProperty('java.version')
    def osName = System.getProperty('os.name').replaceAll('\\s','')
    def osArch = System.getProperty('os.arch')
    def fnameBase = "f${version}_${osName}-${osArch}_jvm${vmVer}"
    def benchMarksDir = "${project.buildDir}/benchmarks"
    ant.mkdir(dir: benchMarksDir)
    // having problems with next 2 lines with a clean ??
    def outStream = new FileOutputStream("${benchMarksDir}/${fnameBase}-out.txt")
    standardOutput = outStream
    main = 'org.funcito.benchmarks.FuncitoBenchmark'
    classpath = sourceSets.test.runtimeClasspath
    args = ['--saveResults', "${benchMarksDir}/${fnameBase}.json", '-Jmode=-server,-client']
}

///////////////////////////
// Cobertura 

// define Cobertura task
ant.taskdef(resource:'tasks.properties') {
    classpath {
        pathelement(path: configurations.testRuntime.asPath)
    }
}

def classesDir = "${project.buildDir}/classes/main"
def origClassesDir = "${project.buildDir}/classes-orig/main"
def coverageDir = "${project.buildDir}/reports/coverage"
def serFile = "cobertura.ser"

test.doFirst { task ->
    ant.delete(file: serFile)
    ant.delete(dir: coverageDir)
    ant.delete(dir: origClassesDir)   
    ant.mkdir(dir: origClassesDir)
        
    ant.copy(todir: origClassesDir) {
        fileset(dir: classesDir)
    }
    
    ant.delete(dir: "${classesDir}/org/funcito/example")
    
    // define Cobertura task
    ant.taskdef(resource: 'tasks.properties') {
        classpath {
            pathelement(path: configurations.testRuntime.asPath)
        }
    }
    
    // instrument the classes
    ant.'cobertura-instrument' {
        // only instrument the relevant classes
        fileset(dir: classesDir,
                includes: "org/funcito/**/*.class", 
                excludes: "org/funcito/thirdparty/**/*.class")
    }        
}
 
test.doLast {
    ant.'cobertura-report'(destdir: coverageDir,
                           format: 'html') {
        fileset(dir: new File('src') ) 
    }

    ant.delete(file: serFile)    
    ant.delete(dir: classesDir)   
    ant.mkdir(dir: classesDir)
        
    ant.copy(todir: classesDir) {
        fileset(dir: origClassesDir)
    } 
}

signing {
    sign jar
    sign sourcesJar
    sign javadocJar
}

// sign all jars
task signAll(overwrite: true, dependsOn: [jarAll,signJar,signJavadocJar,signSourcesJar] ) << {
    // no-op
}

uploadArchives {
    repositories {
        mavenDeployer {
            beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }

            repository(url: "https://oss.sonatype.org/service/local/staging/deploy/maven2/") {
              authentication(userName: sonatypeUsername, password: sonatypePassword)
            }
            pom.whenConfigured { pom ->
               pom.dependencies = pom.dependencies.findAll { dep -> dep.scope != 'test' && dep.groupId != 'org.objenesis' } // removes the test scoped ones
               pom.dependencies.findAll { dep -> dep.scope == 'compile' }*.optional = true // all deps are optional
               pom.dependencies.findAll { dep -> dep.scope == 'compile' }*.scope = 'runtime'
            }

            pom.project {
               name 'Funcito'
               packaging 'jar'
               description 'Funcito is a library for wrapping Java methods as function-types in FP libraries.  This POM is not configured for Maven builds, but only for dependency resolution.'
               url 'http://funcito.googlecode.com/'

               scm {
                   url 'scm:git:https://code.google.com/p/funcito/'
                   connection 'scm:git:https://code.google.com/p/funcito/'
                   developerConnection 'scm:git:https://code.google.com/p/funcito/'
               }

               licenses {
                   license {
                       name 'The Apache Software License, Version 2.0'
                       url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                       distribution 'repo'
                   }
               }

               developers {
                   developer {
                       name 'Kevin Welker'
                   }
               }
            }
            //mess with the generated pom to set the 'packaging' tag
            pom.withXml { XmlProvider xmlProvider ->
               def xml = xmlProvider.asString()
               def pomXml = new XmlParser().parse(new ByteArrayInputStream(xml.toString().bytes))

               pomXml.version[0] + { packaging('jar') }

               def newXml = new StringWriter()
               def printer = new XmlNodePrinter(new PrintWriter(newXml))
               printer.preserveWhitespace = true
               printer.print(pomXml)
               xml.setLength(0)
               xml.append(newXml.toString())
            }
        }
    }
}


