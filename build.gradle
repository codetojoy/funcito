apply plugin: 'java'
apply plugin: 'maven'
apply plugin: 'signing'

group = 'com.googlecode.funcito'
version = '1.0.1'

repositories {
    mavenCentral()
}

configurations {
    jarjar
}

artifacts {
    archives jar
}

dependencies {
    // functional APIs
    compile group: 'com.google.guava', name: 'guava', version: 'r08'
    compile group: 'org.functionaljava', name: 'functionaljava', version: '3.0'
    compile group: 'org.codehaus.jedi', name: 'jedi-core', version: '3.0.5'

    // internals
    compile group: 'cglib', name: 'cglib-nodep', version: '2.2'
    compile group: 'org.objenesis', name: 'objenesis', version: '1.2'
    compile group: 'org.javassist', name: 'javassist', version: '3.14.0-GA'

    // test
    testCompile group: 'junit', name: 'junit', version: '4.10'
    testCompile group: 'org.mockito', name: 'mockito-core', version: '1.8.5'
    
    testRuntime group: 'net.sourceforge.cobertura', name: 'cobertura', version: '1.9.4.1'
    
    // packaging    
    jarjar group: 'com.googlecode.jarjar', name: 'jarjar', version: '1.1'    
}

// sourceSets
sourceSets.main.java.srcDirs 'src', 'examples'
sourceSets.main.resources.srcDir 'resources'
sourceSets.test.java.srcDirs 'test'

///////////////////////////
// Local vars

final String PROP_FILE = "Funcito.properties"
final String BUILD_INFO_FILE = "buildInfo.txt"
final String BUILD_NUMBER = "BUILD_NUMBER"

def vars = new Expando()

// env
vars.envMap = System.getenv()

// version
def propFile = new File("resources/${PROP_FILE}")
assert propFile.exists()
def properties = new Properties()
properties.load(new FileReader(propFile))
version = properties.getProperty('funcito.version')

println "***** Funcito v ${version}"

// CI server versus local

vars.srcJarFilename = "${project.name}-src-${version}.jar"
vars.docJarFilename = "${project.name}-doc-${version}.jar"
vars.binaryJarFilename = "/${project.name}-${version}.jar"

vars.isJenkins = vars.envMap.keySet().contains(BUILD_NUMBER)
 
if (vars.isJenkins) {
    def formatter = new java.text.SimpleDateFormat("dd-MMM-yyyy")
    def now = formatter.format(new Date())
    def buildNumber = vars.envMap.get(BUILD_NUMBER)
    vars.srcJarFilename = "${project.name}-src-SNAPSHOT-${buildNumber}_${now}.jar"
    vars.docJarFilename = "${project.name}-doc-SNAPSHOT-${buildNumber}_${now}.jar"
    vars.binaryJarFilename = "/${project.name}-SNAPSHOT-${buildNumber}_${now}.jar"
}

///////////////////////////
// Tasks

// create build info file
task buildInfo() {
   def buildInfoFile = "resources/${BUILD_INFO_FILE}"
   ant.delete(file: buildInfoFile)
   def jenkinsVars = ["BUILD_NUMBER", "BUILD_ID", "JOB_NAME", "BUILD_TAG",
               "EXECUTOR_NUMBER", "NODE_NAME", "NODE_LABELS", 
               "JAVA_HOME", "WORKSPACE", "HUDSON_URL", "JOB_URL",
               "SVN_REVISION", "CVS_BRANCH"]

   new File(buildInfoFile).withWriter { writer ->
       vars.envMap.each { key, value ->
           if (jenkinsVars.contains(key)) { 
               writer.write("${key} = ${value}\n") 
           }
       }
   }
}

javadoc {
    options.use = true
    options.links = links = [
        'http://docs.oracle.com/javase/1.5.0/docs/api/',
        'http://docs.guava-libraries.googlecode.com/git-history/v11.0.1/javadoc/',
        'http://functionaljava.googlecode.com/svn/artifacts/3.0/javadoc/',
        'http://jedi.codehaus.org/javadoc/'
    ]
}

// build src jar
task sourcesJar(type: Jar, dependsOn: [buildInfo,test]) {
    archiveName = vars.srcJarFilename

    from(sourceSets.main.java.srcDirs) {
        include '**/*.java'
    }

    from(sourceSets.main.resources.srcDirs) {
        include '**/*.properties'
        include '**/*.txt'
    }
    
    from('docs') {
        include 'ReadMe.txt'
        include 'License.txt'
    }
}

task javadocJar(type: Jar, dependsOn: [buildInfo,test,javadoc]) {
    archiveName = vars.docJarFilename

    from('docs') {
        include 'ReadMe.txt'
        include 'License.txt'
    }

    into('docs') {
        from('build/docs') {
            include '**/*.*'
        }
    }
}

task binaryJar(type: Jar, dependsOn: test) {
    def targetDir = "build/libs"
    def targetJar = targetDir + vars.binaryJarFilename
    def classesDir = "build/classes/main"
    
    doLast {
        mkdir(dir: targetDir)
        project.ant {
            // define jarjar
            taskdef name: "jarjar", classname: "com.tonicsystems.jarjar.JarJarTask", classpath: configurations.jarjar.asPath
            jarjar(jarfile: targetJar) {

                fileset(dir: classesDir) {
                    exclude(name: 'org/funcito/example/**/*')
                    exclude(name: 'org/funcito/example')
                }

                fileset(dir: 'resources') {
                    include(name: PROP_FILE)
                    include(name: BUILD_INFO_FILE)
                }

                fileset(dir: 'docs') {
                    include(name: 'ReadMe.txt')
                    include(name: 'License.txt')
                }

                configurations.compile.findAll {
                    if (it.name =~ /objenesis/) {
                        zipfileset(src: "${it.path}")
                    }
                }
                rule(pattern: 'org.objenesis.**', result: 'org.funcito.thirdparty.objenesis.@1')
            }
        }
    }
}

// build all jars
task jarAll(overwrite: true, dependsOn: [sourcesJar,javadocJar,binaryJar] ) << {
    // no-op
}

///////////////////////////
// Cobertura 

// define Cobertura task
ant.taskdef(resource:'tasks.properties') {
    classpath {
        pathelement(path: configurations.testRuntime.asPath)
    }
}

def classesDir = "${project.buildDir}/classes/main"
def origClassesDir = "${project.buildDir}/classes-orig/main"
def coverageDir = "${project.buildDir}/reports/coverage"
def serFile = "cobertura.ser"

test.doFirst { task ->
    ant.delete(file: serFile)
    ant.delete(dir: coverageDir)
    ant.delete(dir: origClassesDir)   
    ant.mkdir(dir: origClassesDir)
        
    ant.copy(todir: origClassesDir) {
        fileset(dir: classesDir)
    }
    
    ant.delete(dir: "${classesDir}/org/funcito/example")
    
    // define Cobertura task
    ant.taskdef(resource: 'tasks.properties') {
        classpath {
            pathelement(path: configurations.testRuntime.asPath)
        }
    }
    
    // instrument the classes
    ant.'cobertura-instrument' {
        // only instrument the relevant classes
        fileset(dir: classesDir,
                includes: "org/funcito/**/*.class", 
                excludes: "org/funcito/thirdparty/**/*.class")
    }        
}
 
test.doLast {
    ant.'cobertura-report'(destdir: coverageDir,
                           format: 'html') {
        fileset(dir: new File('src') ) 
    }

    ant.delete(file: serFile)    
    ant.delete(dir: classesDir)   
    ant.mkdir(dir: classesDir)
        
    ant.copy(todir: classesDir) {
        fileset(dir: origClassesDir)
    } 
}

signing {
    sign binaryJar
    sign sourcesJar
    sign javadocJar
}

// sign all jars
task signAll(overwrite: true, dependsOn: [jarAll,signBinaryJar,signJavadocJar,signSourcesJar] ) << {
    // no-op
}

uploadArchives {
    repositories {
        mavenDeployer {
            beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }

            repository(url: "https://oss.sonatype.org/service/local/staging/deploy/maven2/") {
              authentication(userName: sonatypeUsername, password: sonatypePassword)
            }

            pom.project {
               name 'Funcito'
               packaging 'jar'
               description 'Funcito is a library for wrapping Java methods as Function-object in FP libraries'
               url 'http://funcito.googlecode.com/'

               scm {
                   url 'scm:git:https://code.google.com/p/funcito/'
                   connection 'scm:git:https://code.google.com/p/funcito/'
                   developerConnection 'scm:git:https://code.google.com/p/funcito/'
               }

               licenses {
                   license {
                       name 'The Apache Software License, Version 2.0'
                       url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                       distribution 'repo'
                   }
               }

               developers {
                   developer {
                       name 'Kevin Welker'
                   }
               }
            }
            //mess with the generated pom to set the 'packaging' tag
            pom.withXml { XmlProvider xmlProvider ->
               def xml = xmlProvider.asString()
               def pomXml = new XmlParser().parse(new ByteArrayInputStream(xml.toString().bytes))

               pomXml.version[0] + { packaging('jar') }

               def newXml = new StringWriter()
               def printer = new XmlNodePrinter(new PrintWriter(newXml))
               printer.preserveWhitespace = true
               printer.print(pomXml)
               xml.setLength(0)
               xml.append(newXml.toString())
            }
        }
    }
}


